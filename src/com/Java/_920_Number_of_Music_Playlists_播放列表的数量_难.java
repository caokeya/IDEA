package src.com.Java;

/*
你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：
    每首歌至少播放一次。
    一首歌只有在其他 K 首歌播放完之后才能再次播放。
返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。
示例 1：
输入：N = 3, L = 3, K = 1
输出：6
解释：有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1].
示例 2：
输入：N = 2, L = 3, K = 0
输出：6
解释：有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2]
示例 3：
输入：N = 2, L = 3, K = 1
输出：2
解释：有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2]
 */
public class _920_Number_of_Music_Playlists_播放列表的数量_难 {
    /*
    考虑dp[i][j]。上一首歌，我们要么是第一次演奏，要么不是。
    如果是，那么我们有dp[i-1][j-1] * (N-j)的方法来选择它。
    如果我们没有，那么我们在dp[i-1][j] * max(j-K, 0)的方法中重复前面的一首歌(其中j个，除了最后K个被禁止播放)。
    */
    class Solution {
        public int numMusicPlaylists(int N, int L, int K) {
            int mod = (int) Math.pow(10, 9) + 7;
            long[][] dp = new long[L + 1][N + 1];
            dp[0][0] = 1;
            for (int i = 1; i <= L; i++) {
                for (int j = 1; j <= N; j++) {
                    dp[i][j] = (dp[i - 1][j - 1] * (N - (j - 1))) % mod; // 选了新歌
                    if (j > K) {
                        dp[i][j] = (dp[i][j] + (dp[i - 1][j] * (j - K)) % mod) % mod;// 选了老歌
                    }
                }
            }
            return (int) dp[L][N];
        }
    }
}
