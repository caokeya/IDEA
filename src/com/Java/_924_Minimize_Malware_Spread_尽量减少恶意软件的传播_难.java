package src.com.Java;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。
一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。
这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。
请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。
示例 1：
输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
输出：0
示例 2：
输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
输出：0
示例 3：
输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
输出：1
 */
public class _924_Minimize_Malware_Spread_尽量减少恶意软件的传播_难 {
    class Solution {
        public int minMalwareSpread(int[][] graph, int[] initial) {
            int[] colors = new int[graph.length];
            Arrays.fill(colors, -1);
            int c = 0;
            //Color each island
            for (int i = 0; i < graph.length; i++) {
                if (colors[i] == -1) {
                    dfs(graph, colors, i, c);
                    c++;
                }
            }
            //Size of each island
            int[] size = new int[c];
            for (int i = 0; i < graph.length; i++) {
                size[colors[i]]++;
            }
            //Find unique color
            int[] colorCount = new int[c];
            for (int node : initial) {
                colorCount[colors[node]]++;
            }
            //Answer
            //For each node with a unique color, find the size of the island and return the node with the max size
            //With ties return the lowest index
            //If there is no unique color, return min[initial]
            int res = -1;
            int tempSize = 0;
            for (int node : initial) {
                if (colorCount[colors[node]] == 1) {
                    if (size[colors[node]] > tempSize) {
                        tempSize = size[colors[node]];
                        res = node;
                    } else if (size[colors[node]] == tempSize) {
                        res = Math.min(res, node);
                    }
                }
            }
            if (res == -1) {
                res = graph.length;
                for (int node : initial) {
                    res = Math.min(node, res);
                }
            }
            return res;
        }

        public void dfs(int[][] graph, int[] colors, int node, int color) {
            colors[node] = color;
            for (int i = 0; i < graph.length; i++) {
                if (graph[node][i] == 1 && colors[i] == -1) {
                    dfs(graph, colors, i, color);
                }
            }
            return;
        }
    }


    class Solution2 {
        public int minMalwareSpread(int[][] graph, int[] initial) {
            int N = graph.length;
            DSU dsu = new DSU(N);
            for (int i = 0; i < N; ++i)
                for (int j = i + 1; j < N; ++j)
                    if (graph[i][j] == 1)
                        dsu.union(i, j);

            int[] count = new int[N];
            for (int node : initial)
                count[dsu.find(node)]++;

            int ans = -1, ansSize = -1;
            for (int node : initial) {
                int root = dsu.find(node);
                if (count[root] == 1) {  // unique color
                    int rootSize = dsu.size(root);
                    if (rootSize > ansSize) {
                        ansSize = rootSize;
                        ans = node;
                    } else if (rootSize == ansSize && node < ans) {
                        ansSize = rootSize;
                        ans = node;
                    }
                }
            }

            if (ans == -1) {
                ans = Integer.MAX_VALUE;
                for (int node : initial)
                    ans = Math.min(ans, node);
            }
            return ans;
        }
    }


    class DSU {
        int[] p, sz;

        DSU(int N) {
            p = new int[N];
            for (int x = 0; x < N; ++x)
                p[x] = x;

            sz = new int[N];
            Arrays.fill(sz, 1);
        }

        public int find(int x) {
            if (p[x] != x)
                p[x] = find(p[x]);
            return p[x];
        }

        public void union(int x, int y) {
            int xr = find(x);
            int yr = find(y);
            p[xr] = yr;
            sz[yr] += sz[xr];
        }

        public int size(int x) {
            return sz[find(x)];
        }
    }
}
